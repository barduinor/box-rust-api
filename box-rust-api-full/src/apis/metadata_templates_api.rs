/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`delete_metadata_templates_id_id_schema`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMetadataTemplatesIdIdSchemaParams {
    /// The scope of the metadata template
    pub scope: String,
    /// The name of the metadata template
    pub template_key: String
}

/// struct for passing parameters to the method [`get_metadata_templates`]
#[derive(Clone, Debug, Default)]
pub struct GetMetadataTemplatesParams {
    /// The ID of an instance of the metadata template to find.
    pub metadata_instance_id: String
}

/// struct for passing parameters to the method [`get_metadata_templates_enterprise`]
#[derive(Clone, Debug, Default)]
pub struct GetMetadataTemplatesEnterpriseParams {
    /// Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires `usemarker` to be set to `true`.
    pub marker: Option<String>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`get_metadata_templates_global`]
#[derive(Clone, Debug, Default)]
pub struct GetMetadataTemplatesGlobalParams {
    /// Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires `usemarker` to be set to `true`.
    pub marker: Option<String>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`get_metadata_templates_id`]
#[derive(Clone, Debug, Default)]
pub struct GetMetadataTemplatesIdParams {
    /// The ID of the template
    pub template_id: String
}

/// struct for passing parameters to the method [`get_metadata_templates_id_id_schema`]
#[derive(Clone, Debug, Default)]
pub struct GetMetadataTemplatesIdIdSchemaParams {
    /// The scope of the metadata template
    pub scope: String,
    /// The name of the metadata template
    pub template_key: String
}

/// struct for passing parameters to the method [`post_metadata_templates_schema`]
#[derive(Clone, Debug, Default)]
pub struct PostMetadataTemplatesSchemaParams {
    pub post_metadata_templates_schema_request: Option<crate::models::PostMetadataTemplatesSchemaRequest>
}

/// struct for passing parameters to the method [`put_metadata_templates_id_id_schema`]
#[derive(Clone, Debug, Default)]
pub struct PutMetadataTemplatesIdIdSchemaParams {
    /// The scope of the metadata template
    pub scope: String,
    /// The name of the metadata template
    pub template_key: String,
    pub a_metadata_template_update_operation: Option<Vec<crate::models::AMetadataTemplateUpdateOperation>>
}


/// struct for typed errors of method [`delete_metadata_templates_id_id_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMetadataTemplatesIdIdSchemaError {
    Status400(crate::models::ClientError),
    Status403(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesError {
    Status400(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesEnterpriseError {
    Status400(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_global`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesGlobalError {
    Status400(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesIdError {
    Status400(crate::models::MetadataTemplate),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_id_id_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesIdIdSchemaError {
    Status400(crate::models::ClientError),
    Status404(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_metadata_templates_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostMetadataTemplatesSchemaError {
    Status400(crate::models::ClientError),
    Status403(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_metadata_templates_id_id_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutMetadataTemplatesIdIdSchemaError {
    Status400(crate::models::ClientError),
    Status403(crate::models::ClientError),
    Status404(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}


/// Delete a metadata template and its instances. This deletion is permanent and can not be reversed.
pub async fn delete_metadata_templates_id_id_schema(configuration: &configuration::Configuration, params: DeleteMetadataTemplatesIdIdSchemaParams) -> Result<(), Error<DeleteMetadataTemplatesIdIdSchemaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let scope = params.scope;
    let template_key = params.template_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates/{scope}/{template_key}/schema", local_var_configuration.base_path, scope=crate::apis::urlencode(scope), template_key=crate::apis::urlencode(template_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteMetadataTemplatesIdIdSchemaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Finds a metadata template by searching for the ID of an instance of the template.
pub async fn get_metadata_templates(configuration: &configuration::Configuration, params: GetMetadataTemplatesParams) -> Result<crate::models::MetadataTemplates, Error<GetMetadataTemplatesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let metadata_instance_id = params.metadata_instance_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("metadata_instance_id", &metadata_instance_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMetadataTemplatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Used to retrieve all metadata templates created to be used specifically within the user's enterprise
pub async fn get_metadata_templates_enterprise(configuration: &configuration::Configuration, params: GetMetadataTemplatesEnterpriseParams) -> Result<crate::models::MetadataTemplates, Error<GetMetadataTemplatesEnterpriseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let marker = params.marker;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates/enterprise", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = marker {
        local_var_req_builder = local_var_req_builder.query(&[("marker", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMetadataTemplatesEnterpriseError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Used to retrieve all generic, global metadata templates available to all enterprises using Box.
pub async fn get_metadata_templates_global(configuration: &configuration::Configuration, params: GetMetadataTemplatesGlobalParams) -> Result<crate::models::MetadataTemplates, Error<GetMetadataTemplatesGlobalError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let marker = params.marker;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates/global", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = marker {
        local_var_req_builder = local_var_req_builder.query(&[("marker", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMetadataTemplatesGlobalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a metadata template by its ID.
pub async fn get_metadata_templates_id(configuration: &configuration::Configuration, params: GetMetadataTemplatesIdParams) -> Result<crate::models::MetadataTemplate, Error<GetMetadataTemplatesIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let template_id = params.template_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates/{template_id}", local_var_configuration.base_path, template_id=crate::apis::urlencode(template_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMetadataTemplatesIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a metadata template by its `scope` and `templateKey` values.  To find the `scope` and `templateKey` for a template, list all templates for an enterprise or globally, or list all templates applied to a file or folder.
pub async fn get_metadata_templates_id_id_schema(configuration: &configuration::Configuration, params: GetMetadataTemplatesIdIdSchemaParams) -> Result<crate::models::MetadataTemplate, Error<GetMetadataTemplatesIdIdSchemaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let scope = params.scope;
    let template_key = params.template_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates/{scope}/{template_key}/schema", local_var_configuration.base_path, scope=crate::apis::urlencode(scope), template_key=crate::apis::urlencode(template_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMetadataTemplatesIdIdSchemaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new metadata template that can be applied to files and folders.
pub async fn post_metadata_templates_schema(configuration: &configuration::Configuration, params: PostMetadataTemplatesSchemaParams) -> Result<crate::models::MetadataTemplate, Error<PostMetadataTemplatesSchemaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_metadata_templates_schema_request = params.post_metadata_templates_schema_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates/schema", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&post_metadata_templates_schema_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostMetadataTemplatesSchemaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a metadata template.  The metadata template can only be updated if the template already exists.  The update is applied atomically. If any errors occur during the application of the operations, the metadata template will not be changed.
pub async fn put_metadata_templates_id_id_schema(configuration: &configuration::Configuration, params: PutMetadataTemplatesIdIdSchemaParams) -> Result<crate::models::MetadataTemplate, Error<PutMetadataTemplatesIdIdSchemaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let scope = params.scope;
    let template_key = params.template_key;
    let a_metadata_template_update_operation = params.a_metadata_template_update_operation;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/metadata_templates/{scope}/{template_key}/schema", local_var_configuration.base_path, scope=crate::apis::urlencode(scope), template_key=crate::apis::urlencode(template_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&a_metadata_template_update_operation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PutMetadataTemplatesIdIdSchemaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

