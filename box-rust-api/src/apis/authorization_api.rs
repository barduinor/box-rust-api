/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`get_authorize`]
#[derive(Clone, Debug, Default)]
pub struct GetAuthorizeParams {
    /// The type of response we'd like to receive.
    pub response_type: String,
    /// The Client ID of the application that is requesting to authenticate the user. To get the Client ID for your application, log in to your Box developer console and click the **Edit Application** link for the application you're working with. In the OAuth 2.0 Parameters section of the configuration page, find the item labelled `client_id`. The text of that item is your application's Client ID.
    pub client_id: String,
    /// The URI to which Box redirects the browser after the user has granted or denied the application permission. This URI match one of the redirect URIs in the configuration of your application. It must be a valid HTTPS URI and it needs to be able to handle the redirection to complete the next step in the OAuth 2.0 flow. Although this parameter is optional, it must be a part of the authorization URL if you configured multiple redirect URIs for the application in the developer console. A missing parameter causes a `redirect_uri_missing` error after the user grants application access.
    pub redirect_uri: Option<String>,
    /// A custom string of your choice. Box will pass the same string to the redirect URL when authentication is complete. This parameter can be used to identify a user on redirect, as well as protect against hijacked sessions and other exploits.
    pub state: Option<String>,
    /// A comma-separated list of application scopes you'd like to authenticate the user for. This defaults to all the scopes configured for the application in its configuration page.
    pub scope: Option<String>,
}

/// struct for passing parameters to the method [`post_oauth2_revoke`]
#[derive(Clone, Debug, Default)]
pub struct PostOauth2RevokeParams {
    /// The Client ID of the application requesting to revoke the access token.
    pub client_id: Option<String>,
    /// The client secret of the application requesting to revoke an access token.
    pub client_secret: Option<String>,
    /// The access token to revoke.
    pub token: Option<String>,
}

/// struct for passing parameters to the method [`post_oauth2_token`]
#[derive(Clone, Debug, Default)]
pub struct PostOauth2TokenParams {
    /// The type of request being made, either using a client-side obtained authorization code, a refresh token, a JWT assertion, client credentials grant or another access token for the purpose of downscoping a token.
    pub grant_type: String,
    /// The Client ID of the application requesting an access token.  Used in combination with `authorization_code`, `client_credentials`, or `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    pub client_id: Option<String>,
    /// The client secret of the application requesting an access token.  Used in combination with `authorization_code`, `client_credentials`, or `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    pub client_secret: Option<String>,
    /// The client-side authorization code passed to your application by Box in the browser redirect after the user has successfully granted your application permission to make API calls on their behalf.  Used in combination with `authorization_code` as the `grant_type`.
    pub code: Option<String>,
    /// A refresh token used to get a new access token with.  Used in combination with `refresh_token` as the `grant_type`.
    pub refresh_token: Option<String>,
    /// A JWT assertion for which to request a new access token.  Used in combination with `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    pub assertion: Option<String>,
    /// The token to exchange for a downscoped token. This can be a regular access token, a JWT assertion, or an app token.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    pub subject_token: Option<String>,
    /// The type of `subject_token` passed in.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    pub subject_token_type: Option<String>,
    /// The token used to create an annotator token. This is a JWT assertion.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    pub actor_token: Option<String>,
    /// The type of `actor_token` passed in.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    pub actor_token_type: Option<String>,
    /// The space-delimited list of scopes that you want apply to the new access token.  The `subject_token` will need to have all of these scopes or the call will error with **401 Unauthorized**.
    pub scope: Option<String>,
    /// Full URL for the file that the token should be generated for.
    pub resource: Option<String>,
    /// Used in combination with `client_credentials` as the `grant_type`.
    pub box_subject_type: Option<String>,
    /// Used in combination with `client_credentials` as the `grant_type`. Value is determined by `box_subject_type`. If `user` use user ID and if `enterprise` use enterprise ID.
    pub box_subject_id: Option<String>,
    /// Full URL of the shared link on the file or folder that the token should be generated for.
    pub box_shared_link: Option<String>,
}

/// struct for passing parameters to the method [`post_oauth2_token_refresh`]
#[derive(Clone, Debug, Default)]
pub struct PostOauth2TokenRefreshParams {
    /// The type of request being made, in this case a refresh request.
    pub grant_type: String,
    /// The client ID of the application requesting to refresh the token.
    pub client_id: String,
    /// The client secret of the application requesting to refresh the token.
    pub client_secret: String,
    /// The refresh token to refresh.
    pub refresh_token: String,
}

/// struct for typed errors of method [`get_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthorizeError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_oauth2_revoke`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostOauth2RevokeError {
    Status400(crate::models::OAuth2Error),
    DefaultResponse(crate::models::OAuth2Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_oauth2_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostOauth2TokenError {
    Status400(crate::models::OAuth2Error),
    DefaultResponse(crate::models::OAuth2Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_oauth2_token_refresh`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostOauth2TokenRefreshError {
    Status400(crate::models::OAuth2Error),
    DefaultResponse(crate::models::OAuth2Error),
    UnknownValue(serde_json::Value),
}

pub fn get_authorizarion_url(params: GetAuthorizeParams) -> String {
    let mut url = String::from("https://account.box.com/api/oauth2/authorize?");
    url.push_str("response_type=");
    url.push_str(&"code".to_string());
    url.push_str("&client_id=");
    url.push_str(&params.client_id);
    if let Some(ref local_var_str) = params.redirect_uri {
        url.push_str("&redirect_uri=");
        url.push_str(&urlencoding::encode(&local_var_str).to_string());
    }
    if let Some(ref local_var_str) = params.state {
        url.push_str("&state=");
        url.push_str(&local_var_str.to_string());
    }

    if let Some(ref local_var_str) = params.scope {
        url.push_str("&scope=");
        url.push_str(&local_var_str.to_string());
    }
    url
}

// /// Authorize a user by sending them through the [Box](https://box.com) website and request their permission to act on their behalf.  This is the first step when authenticating a user using OAuth 2.0. To request a user's authorization to use the Box APIs on their behalf you will need to send a user to the URL with this format.
// pub async fn get_authorize(
//     configuration: &configuration::Configuration,
//     params: GetAuthorizeParams,
// ) -> Result<String, Error<GetAuthorizeError>> {
//     let local_var_configuration = configuration;

//     // unbox the parameters
//     let response_type = params.response_type;
//     let client_id = params.client_id;
//     let redirect_uri = params.redirect_uri;
//     let state = params.state;
//     let scope = params.scope;

//     let local_var_client = &local_var_configuration.client;

//     let local_var_uri_str = format!("{}/authorize", local_var_configuration.base_path);
//     let mut local_var_req_builder =
//         local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

//     local_var_req_builder =
//         local_var_req_builder.query(&[("response_type", &response_type.to_string())]);
//     local_var_req_builder = local_var_req_builder.query(&[("client_id", &client_id.to_string())]);
//     if let Some(ref local_var_str) = redirect_uri {
//         local_var_req_builder =
//             local_var_req_builder.query(&[("redirect_uri", &local_var_str.to_string())]);
//     }
//     if let Some(ref local_var_str) = state {
//         local_var_req_builder =
//             local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
//     }
//     if let Some(ref local_var_str) = scope {
//         local_var_req_builder =
//             local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
//     }
//     if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
//         local_var_req_builder =
//             local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
//     }

//     let local_var_req = local_var_req_builder.build()?;
//     println!("\n{:?}\n", local_var_req);

//     let local_var_resp = local_var_client.execute(local_var_req).await?;
//     println!("\n{:?}\n", local_var_resp);

//     let local_var_status = local_var_resp.status();
//     let local_var_content = local_var_resp.text().await?;

//     if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
//         serde_json::from_str(&local_var_content).map_err(Error::from)
//     } else {
//         let local_var_entity: Option<GetAuthorizeError> =
//             serde_json::from_str(&local_var_content).ok();
//         let local_var_error = ResponseContent {
//             status: local_var_status,
//             content: local_var_content,
//             entity: local_var_entity,
//         };
//         Err(Error::ResponseError(local_var_error))
//     }
// }

/// Revoke an active Access Token, effectively logging a user out that has been previously authenticated.
pub async fn post_oauth2_revoke(
    configuration: &configuration::Configuration,
    params: PostOauth2RevokeParams,
) -> Result<(), Error<PostOauth2RevokeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let client_id = params.client_id;
    let client_secret = params.client_secret;
    let token = params.token;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/revoke", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = client_id {
        local_var_form_params.insert("client_id", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_secret {
        local_var_form_params.insert("client_secret", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = token {
        local_var_form_params.insert("token", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostOauth2RevokeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Request an Access Token using either a client-side obtained OAuth 2.0 authorization code or a server-side JWT assertion.  An Access Token is a string that enables Box to verify that a request belongs to an authorized session. In the normal order of operations you will begin by requesting authentication from the [authorize](#get-authorize) endpoint and Box will send you an authorization code.  You will then send this code to this endpoint to exchange it for an Access Token. The returned Access Token can then be used to to make Box API calls.
pub async fn post_oauth2_token(
    configuration: &configuration::Configuration,
    params: PostOauth2TokenParams,
) -> Result<crate::models::AccessToken, Error<PostOauth2TokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let grant_type = params.grant_type;
    let client_id = params.client_id;
    let client_secret = params.client_secret;
    let code = params.code;
    let refresh_token = params.refresh_token;
    let assertion = params.assertion;
    let subject_token = params.subject_token;
    let subject_token_type = params.subject_token_type;
    let actor_token = params.actor_token;
    let actor_token_type = params.actor_token_type;
    let scope = params.scope;
    let resource = params.resource;
    let box_subject_type = params.box_subject_type;
    let box_subject_id = params.box_subject_id;
    let box_shared_link = params.box_shared_link;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/token", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("grant_type", grant_type.to_string());
    if let Some(local_var_param_value) = client_id {
        local_var_form_params.insert("client_id", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = client_secret {
        local_var_form_params.insert("client_secret", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = code {
        local_var_form_params.insert("code", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = refresh_token {
        local_var_form_params.insert("refresh_token", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = assertion {
        local_var_form_params.insert("assertion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = subject_token {
        local_var_form_params.insert("subject_token", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = subject_token_type {
        local_var_form_params.insert("subject_token_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = actor_token {
        local_var_form_params.insert("actor_token", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = actor_token_type {
        local_var_form_params.insert("actor_token_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = scope {
        local_var_form_params.insert("scope", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = resource {
        local_var_form_params.insert("resource", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = box_subject_type {
        local_var_form_params.insert("box_subject_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = box_subject_id {
        local_var_form_params.insert("box_subject_id", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = box_shared_link {
        local_var_form_params.insert("box_shared_link", local_var_param_value.to_string());
    }

    // println!("\n{:?}\n", local_var_form_params);
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);
    // local_var_req_builder = local_var_req_builder.json(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    // println!("\n{:?}\n", local_var_req);
    // println!("\n{:?}\n", Some(local_var_req.body()));

    let local_var_resp = local_var_client.execute(local_var_req).await?;
    // println!("\n{:?}\n", local_var_resp);

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostOauth2TokenError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Refresh an Access Token using its client ID, secret, and refresh token.
pub async fn post_oauth2_token_refresh(
    configuration: &configuration::Configuration,
    params: PostOauth2TokenRefreshParams,
) -> Result<crate::models::AccessToken, Error<PostOauth2TokenRefreshError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let grant_type = params.grant_type;
    let client_id = params.client_id;
    let client_secret = params.client_secret;
    let refresh_token = params.refresh_token;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth2/token#refresh", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("grant_type", grant_type.to_string());
    local_var_form_params.insert("client_id", client_id.to_string());
    local_var_form_params.insert("client_secret", client_secret.to_string());
    local_var_form_params.insert("refresh_token", refresh_token.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostOauth2TokenRefreshError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
