/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`delete_files_upload_sessions_id`]
#[derive(Clone, Debug, Default)]
pub struct DeleteFilesUploadSessionsIdParams {
    /// The ID of the upload session.
    pub upload_session_id: String
}

/// struct for passing parameters to the method [`get_files_upload_sessions_id`]
#[derive(Clone, Debug, Default)]
pub struct GetFilesUploadSessionsIdParams {
    /// The ID of the upload session.
    pub upload_session_id: String
}

/// struct for passing parameters to the method [`get_files_upload_sessions_id_parts`]
#[derive(Clone, Debug, Default)]
pub struct GetFilesUploadSessionsIdPartsParams {
    /// The ID of the upload session.
    pub upload_session_id: String,
    /// The offset of the item at which to begin the response.  Queries with offset parameter value exceeding 10000 will be rejected with a 400 response.
    pub offset: Option<i64>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`post_files_id_upload_sessions`]
#[derive(Clone, Debug, Default)]
pub struct PostFilesIdUploadSessionsParams {
    /// The unique identifier that represents a file.  The ID for any file can be determined by visiting a file in the web application and copying the ID from the URL. For example, for the URL `https://_*.app.box.com/files/123` the `file_id` is `123`.
    pub file_id: String,
    pub post_files_id_upload_sessions_request: Option<crate::models::PostFilesIdUploadSessionsRequest>
}

/// struct for passing parameters to the method [`post_files_upload_sessions`]
#[derive(Clone, Debug, Default)]
pub struct PostFilesUploadSessionsParams {
    pub post_files_upload_sessions_request: Option<crate::models::PostFilesUploadSessionsRequest>
}

/// struct for passing parameters to the method [`post_files_upload_sessions_id_commit`]
#[derive(Clone, Debug, Default)]
pub struct PostFilesUploadSessionsIdCommitParams {
    /// The ID of the upload session.
    pub upload_session_id: String,
    /// The [RFC3230][1] message digest of the whole file.  Only SHA1 is supported. The SHA1 digest must be Base64 encoded. The format of this header is as `sha=BASE64_ENCODED_DIGEST`.  [1]: https://tools.ietf.org/html/rfc3230
    pub digest: String,
    /// Ensures this item hasn't recently changed before making changes.  Pass in the item's last observed `etag` value into this header and the endpoint will fail with a `412 Precondition Failed` if it has changed since.
    pub if_match: Option<String>,
    /// Ensures an item is only returned if it has changed.  Pass in the item's last observed `etag` value into this header and the endpoint will fail with a `304 Not Modified` if the item has not changed since.
    pub if_none_match: Option<String>,
    pub post_files_upload_sessions_id_commit_request: Option<crate::models::PostFilesUploadSessionsIdCommitRequest>
}

/// struct for passing parameters to the method [`put_files_upload_sessions_id`]
#[derive(Clone, Debug, Default)]
pub struct PutFilesUploadSessionsIdParams {
    /// The ID of the upload session.
    pub upload_session_id: String,
    /// The [RFC3230][1] message digest of the chunk uploaded.  Only SHA1 is supported. The SHA1 digest must be base64 encoded. The format of this header is as `sha=BASE64_ENCODED_DIGEST`.  To get the value for the `SHA` digest, use the openSSL command to encode the file part: `openssl sha1 -binary <FILE_PART_NAME> | base64`  [1]: https://tools.ietf.org/html/rfc3230
    pub digest: String,
    /// The byte range of the chunk.  Must not overlap with the range of a part already uploaded this session. Each partâ€™s size must be exactly equal in size to the part size specified in the upload session that you created. One exception is the last part of the file, as this can be smaller.  When providing the value for `content-range`, remember that:  * The lower bound of each part's byte range   must be a multiple of the part size. * The higher bound must be a multiple of the part size - 1.
    pub content_range: String,
    pub body: Option<std::path::PathBuf>
}


/// struct for typed errors of method [`delete_files_upload_sessions_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFilesUploadSessionsIdError {
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_files_upload_sessions_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesUploadSessionsIdError {
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_files_upload_sessions_id_parts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesUploadSessionsIdPartsError {
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_files_id_upload_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesIdUploadSessionsError {
    Status409(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_files_upload_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesUploadSessionsError {
    Status400(crate::models::ClientError),
    Status403(crate::models::ClientError),
    Status404(crate::models::ClientError),
    Status409(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_files_upload_sessions_id_commit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesUploadSessionsIdCommitError {
    Status409(crate::models::ClientError),
    Status412(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_files_upload_sessions_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutFilesUploadSessionsIdError {
    Status409(crate::models::ClientError),
    Status412(crate::models::ClientError),
    Status416(crate::models::ClientError),
    DefaultResponse(crate::models::ClientError),
    UnknownValue(serde_json::Value),
}


/// Abort an upload session and discard all data uploaded.  This cannot be reversed.
pub async fn delete_files_upload_sessions_id(configuration: &configuration::Configuration, params: DeleteFilesUploadSessionsIdParams) -> Result<(), Error<DeleteFilesUploadSessionsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let upload_session_id = params.upload_session_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/upload_sessions/{upload_session_id}", local_var_configuration.base_path, upload_session_id=crate::apis::urlencode(upload_session_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteFilesUploadSessionsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return information about an upload session.
pub async fn get_files_upload_sessions_id(configuration: &configuration::Configuration, params: GetFilesUploadSessionsIdParams) -> Result<crate::models::UploadSession, Error<GetFilesUploadSessionsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let upload_session_id = params.upload_session_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/upload_sessions/{upload_session_id}", local_var_configuration.base_path, upload_session_id=crate::apis::urlencode(upload_session_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFilesUploadSessionsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return a list of the chunks uploaded to the upload session so far.
pub async fn get_files_upload_sessions_id_parts(configuration: &configuration::Configuration, params: GetFilesUploadSessionsIdPartsParams) -> Result<crate::models::UploadParts, Error<GetFilesUploadSessionsIdPartsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let upload_session_id = params.upload_session_id;
    let offset = params.offset;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/upload_sessions/{upload_session_id}/parts", local_var_configuration.base_path, upload_session_id=crate::apis::urlencode(upload_session_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFilesUploadSessionsIdPartsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates an upload session for an existing file.
pub async fn post_files_id_upload_sessions(configuration: &configuration::Configuration, params: PostFilesIdUploadSessionsParams) -> Result<crate::models::UploadSession, Error<PostFilesIdUploadSessionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let file_id = params.file_id;
    let post_files_id_upload_sessions_request = params.post_files_id_upload_sessions_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/{file_id}/upload_sessions", local_var_configuration.base_path, file_id=crate::apis::urlencode(file_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&post_files_id_upload_sessions_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostFilesIdUploadSessionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates an upload session for a new file.
pub async fn post_files_upload_sessions(configuration: &configuration::Configuration, params: PostFilesUploadSessionsParams) -> Result<crate::models::UploadSession, Error<PostFilesUploadSessionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_files_upload_sessions_request = params.post_files_upload_sessions_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/upload_sessions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&post_files_upload_sessions_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostFilesUploadSessionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Close an upload session and create a file from the uploaded chunks.
pub async fn post_files_upload_sessions_id_commit(configuration: &configuration::Configuration, params: PostFilesUploadSessionsIdCommitParams) -> Result<crate::models::Files, Error<PostFilesUploadSessionsIdCommitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let upload_session_id = params.upload_session_id;
    let digest = params.digest;
    let if_match = params.if_match;
    let if_none_match = params.if_none_match;
    let post_files_upload_sessions_id_commit_request = params.post_files_upload_sessions_id_commit_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/upload_sessions/{upload_session_id}/commit", local_var_configuration.base_path, upload_session_id=crate::apis::urlencode(upload_session_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("digest", digest.to_string());
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("if-match", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = if_none_match {
        local_var_req_builder = local_var_req_builder.header("if-none-match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&post_files_upload_sessions_id_commit_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostFilesUploadSessionsIdCommitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a chunk of an upload session for a file.
pub async fn put_files_upload_sessions_id(configuration: &configuration::Configuration, params: PutFilesUploadSessionsIdParams) -> Result<crate::models::UploadedPart, Error<PutFilesUploadSessionsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let upload_session_id = params.upload_session_id;
    let digest = params.digest;
    let content_range = params.content_range;
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/files/upload_sessions/{upload_session_id}", local_var_configuration.base_path, upload_session_id=crate::apis::urlencode(upload_session_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("digest", digest.to_string());
    local_var_req_builder = local_var_req_builder.header("content-range", content_range.to_string());
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PutFilesUploadSessionsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

